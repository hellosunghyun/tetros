; ==============================================================================
; 디버그 매크로 모음
; ==============================================================================
; 이 파일은 테트로스 개발 중 디버깅을 위한 유틸리티 매크로를 포함합니다.
; DEBUG 플래그가 정의된 경우에만 메인 파일(tetros.asm)에 포함됩니다.
;
; 주의: 이 매크로들은 릴리스 빌드에는 포함되지 않습니다.
;       부트섹터의 446바이트 제한 때문에 디버그 코드는 제외해야 합니다.
; ==============================================================================

; ------------------------------------------------------------------------------
; print_reg 매크로: 16비트 레지스터 값을 이진수로 화면에 출력
; ------------------------------------------------------------------------------
; 입력: %1 = 출력할 16비트 값 (레지스터 또는 메모리)
;
; 기능:
; - 16비트 값을 2진수 문자열로 변환하여 화면에 출력
; - 각 비트를 '0' 또는 '1' 문자로 표시
; - 디버깅 시 레지스터나 메모리 값을 시각적으로 확인할 때 유용
;
; 출력 형식:
; - 16개의 '0' 또는 '1' 문자가 연속으로 출력됨
; - 예: 0xFF00 → "1111111100000000"
;
; 사용 예:
;   print_reg ax      ; AX 레지스터 값을 이진수로 출력
;   print_reg [bx]    ; BX가 가리키는 메모리의 값을 이진수로 출력
;
; 주의: 이 매크로는 실행 후 무한 루프(jmp $)에 빠집니다!
;       디버깅 용도로만 사용하고, 정상 실행 시에는 사용하지 마세요.
; ------------------------------------------------------------------------------
%macro print_reg 1
	mov dx, %1                     ; DX = 출력할 16비트 값
	mov cx, 16                     ; CX = 16 (16비트를 처리할 루프 카운터)

print_reg_loop:                    ; 비트 출력 루프 시작
	push cx                        ; 루프 카운터 저장

	; --- 현재 최상위 비트 확인 및 문자 선택 ---
	mov al, '0'                    ; 기본값: '0' 문자 (ASCII 48)
	test dh, 10000000b             ; DH의 최상위 비트(비트 7) 테스트
	jz print_reg_do                ; 비트가 0이면 '0' 그대로 사용
	mov al, '1'                    ; 비트가 1이면 '1' 문자로 변경 (ASCII 49)

print_reg_do:                      ; 문자 출력 수행
	; --- BIOS를 사용하여 문자 출력 ---
	mov bx, 0x0006                 ; BH=0 (페이지 0), BL=06h (회색, 검정 배경)
	                               ; 색상: 전경=회색(6), 배경=검정(0)
	mov ah, 0x09                   ; BIOS 함수: 커서 위치에 문자 출력
	mov cx, 1                      ; 출력 횟수 = 1회
	int 0x10                       ; 비디오 인터럽트 호출 (AL의 문자 출력)

	; --- 커서를 다음 열로 이동 ---
	mov ah, 3                      ; BIOS 함수: 현재 커서 위치 읽기
	int 0x10                       ; DH=행, DL=열 반환
	inc dx                         ; DL++ (다음 열로, 실제로는 DX 전체 증가)
	                               ; 주의: 여기서 DH도 증가될 수 있음 (버그 가능성)
	mov ah, 2                      ; BIOS 함수: 커서 위치 설정
	int 0x10                       ; 새 위치로 커서 이동

	; --- 다음 비트 처리 준비 ---
	pop cx                         ; 루프 카운터 복원
	shl dx, 1                      ; DX를 왼쪽으로 1비트 시프트
	                               ; (다음 비트가 최상위 비트 위치로 이동)
	loop print_reg_loop            ; CX-- 후 CX≠0이면 루프 반복

	; --- 디버그 정지점: 무한 루프 ---
	jmp $                          ; 여기서 정지 (출력 결과 확인용)
	                               ; '$'는 현재 명령어 주소를 의미
	                               ; 따라서 영원히 같은 위치로 점프 = 무한 루프
%endmacro
